
Effective C# 第一版が出版された2004年からみて、C#のコミュニティは大きく変化してきた。
（C++やJavaではなく）C#を１つ目の言語とする人も多くなった。
著者は言語自身の変化だけでなく、コミュニティの変化にも配慮して、この第三版を書いた
（演者注：C++やJavaの経験を想定しないということだと思う）。

本書では歴史的経緯の話はしない。
今のC#の話をする。

旧版の読者はMore Effective C# 第一版の内容が本書に含まれていることに気づくだろう。
（2017年8月に出版される）新しいMore Effective C#では別の事項について書く。

本書はC# 6.0を仮定するが、新機能を網羅的に扱うわけではない。
他のEffecitiveシリーズと同様に、実践的な使い方について書く。

本書は日々のツールセットの一部としてC#を使っているプロの開発者向けに書かれている。
読者はC#の構文や機能についてよく知っていることを仮定する。
（演者注：この勉強会では構文や機能についての復習も多少はしましょう）。

About The Content
各章の概要が書いてありますが、省略します。
上手に説明できる自信がないので。。。

Code Convention
サンプルコードではtry/finally節は省略する。

暗黙的に以下のusingステートメントをインクルードしている。
using System;
using static System.Console;
using System.Collections.Generic;
using System.Linq;
using System.Text;

演者注：
本書は歴史の話をしないと言うが、一応。

C# 1.0(2002)
C# 2.0(2005) ジェネリック
C# 3.0(2007) LINQ、型推論
C# 4.0(2010) dynamic
C# 5.0(2012) acync/await
C# 6.0(2015) 自動プロパティ
C# 7.0(2017) タプル、参照戻り値

Visual Studio 2013で使えるのはC# 5.0

1. C# Language Idioms

C#はC++とJavaに似ていて、それらのイディオムをそのまま使うこともできてしまったりするけれども、
C#を最大限に活用するためには、C#固有のイディオムをちゃんと理解しよう。


Item 1: Prefer Implicitly Typed Local Variables

C# 3.0で暗黙的型付け（型推論）が導入された動機は２つ。

１．匿名型
２．LINQの戻り値の型（IQueryable<T>, IEnumerable<T>）

匿名型はvarで受けるしかない。

LINQのクエリメソッドの戻り値の型は
IQueryable<T>だったりIEnumerable<T>だったりする。

IQueryable<T>は、IEnumerable<T>のサブクラスなので、
IQueryable<T>をIEnumerable<T>にアップキャストすることはできてしまう。
しかし、IQueryProviderによって提供されるenhancementを見逃してしまう（Item 42参照）。

varの使用によって、開発者はコードをよりよく理解することができる。
Dictionary<int, Queue<string>>のような型を見ても理解の助けにならないが、
jobsQueuedByRegionのような変数名は理解の助けになる。

著者はvarを多くのローカル変数に対して使うことを好む。
なぜならば、開発者の注意を（意味論的に）重要なところに集中させることができるからである。

varを使っても、コンパイラは型検査をして型の間違いを警告してくれる（型安全性が全く同じというわけではないが）。

多くの場合、IQueryableとIEnumerableを明示的に書くことは開発者に何の情報も与えないだろう。
しかし、明示的に書くと振る舞いを変えてしまうことに気づくだろう（Item42 参照）。

ある時には、コンパイラがあなたよりも良い型を選べるので、暗黙的型付けを使った方が良い。
しかし、またある時には、varを使いすぎることによって、可読性を下げてしまう。
さらに悪いことに、暗黙的型付けはわかりにくい変換バグの原因になってしまう。

まず最初に、動的型付けとは違うことを理解する必要がある。
暗黙的型付けでは右辺の型によって型が暗黙的に宣言される。
varを使うことによって、コンパイラはあなたの代わりに型を宣言してくれるのだ。

演者注：暗黙的型付けは基本的には型安全である。
なので残る主な問題は可読性の問題である。

可読性の問題について考えてみよう。

具体例がいろいろ書いてある。
ちゃんと変数名を付けておけば（意味論的には）読めるはず。


コードを読む人間は１つの（具象的な）型を想像する。
この型は実行時にはたぶん正しいだろう。
一方、コンパイラはコンパイル時の型のみを推論する。

