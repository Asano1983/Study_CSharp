Item 28 拡張メソッドによって構築された型を強化することを考えよう

あなたはたぶん、たくさんの構築されたジェネリック型をあなたのアプリケーションで使うだろう。
あなたはList<int>やDictionary<EmployeeID, Employee>、多くの他のコレクションなど特定のコレクション型を作るかもしれない、
これらのコレクションを作る目的は、
あなたのアプリケーションがある特定の型のコレクションに対する特定の必要性を持っていること、
それらの特定の構築された型に対して定義された特定の振る舞いを持ってほしいことである。
少ない負担で、この機能性を実装するために、あなたは特定の構築された型の上に拡張メソッドたちを作ることができる。

このパターンはSystem.Linq.Enumerableクラスに見ることができる。
この章のItem27の初めの方で議論したように、IEnumerable<T>の拡張メソッドのようなシーケンスに対して多くの共通のメソッドを実装するために、
拡張パターンはEnumerable<T>で使われている。
さらにEnumerableは多くのメソッドを含む、特別に実装された、IEnumerable<T>を実装している特定の構築された型のために、

（以下具体例、省略）

一度このパターンを理解すれば、あなたは多くの方法を見つけることができるだろう、あなたが実装する同じような拡張、あなたのドメインで構築された型に対して。

もし、あなたが拡張メソッドを知らなかったら、この構築されたジェネリック型から新しい型を派生することで同様の効果を達成しようとするかもしれない。
（具体例）

これは機能する、しかし、これは多くを制限している、この顧客リストのユーザーに対して、IEnumerable<Customer>の上の拡張メソッドに比べて。
理由の一つはメソッドのシグネチャの違いである。
拡張メソッドはIEnumerable<Customer>がパラメータとして使われているが、派生クラスに追加されたメソッドはList<Customer>に基づいている。
これは特定のストレージモデルを強制している。
またこの理由で、イテレータメソッドの集まりに構成されることができない（遅延評価できない、詳しくはItem 31）。
不必要な制約をユーザーに強いている。
これは継承の間違えた使い方である（機能追加のために継承を使うべきではない）。

拡張メソッドを使うべきもう一つの理由は、クエリーとして使いたいときである。
その方が再利用性が高いだろう。

１．System.Linq.Enumerableクラスの説明。拡張メソッドを使うことで後からメソッドを追加できる。
